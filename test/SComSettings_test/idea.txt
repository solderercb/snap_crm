В предыдущей версии с помощью директив препроцессора создавались переменная и несколько методов для каждого поля: читаемость кода плохая, дольше длится компиляция и ощутимо больший размер исполняемого файла.

В новой версии используется тот же принцип хранения данных, что и для объектов представляющих одну запись в таблице:
 - данные, загруженные из базы, хранятся в QSqlRecord;
 - в конструкторе класса вызывается метод инициализации QSqlRecord; тело метода генерируется на этапе препроцессора с помощью макросов, названия полей сохраняются и далее используются при формировании запросов;
 - изменения данных сохраняются в кэш и все последующие манипуляции с такими данными также используют кэш;
 - запись в БД производится только тех данных, которые были зименены; метка об изменении устанавливается в методе setData();
 - поля со сложными данными (например, содержащие JSON):
   а) могут быть представлены несколькими "простыми" полями (подробнее о них ниже) и соответствующими им виджетами;
   б) могут быть задекларированы с указанием NoWidget (если разделяются на простые)
   в) имеют индекс как и любое другое поле класса (сквозная индексация);
   г) при загрузке данных из БД обрабатываются для инициализации "простых" полей;
   д) при изменении "сырых" данных в таком поле с помощью сигнально-слотовой системы обовляются данные в простых полях;
 - простые дополнительные поля класса, являющиеся представлениями для данных в сложных полях (например, содержащих JSON):
   а) при декларации вместо имени поля таблицы указывается специальное слово IGNORE;
   б) не добавляются в список полей QSqlRecord;
   в) значения хранятся только в кэше;
   г) имеют индекс как и любое другое поле класса (сквозная индексация);
   д) при изменении такого поля с помощью сигнально-слотовой системы обовляются данные в поле со сложными данными;
 - инициализация виджетов происходит при вызове соответствующего метода и только когда виджеты понадобятся (открытие вкладки настроек);
 - для инициализации виджетов используется вариативные шаблоны;
  